## Polyfills

```javascript
// Polyfill for Array.prototype.map
if (!Array.prototype.map) {
  Array.prototype.map = function(callback, thisArg) {
    if (this == null) {
      throw new TypeError('Array.prototype.map called on null or undefined');
    }
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    const O = Object(this);
    const len = O.length >>> 0;
    const T = thisArg;
    const A = new Array(len);

    for (let k = 0; k < len; k++) {
      if (k in O) {
        A[k] = callback.call(T, O[k], k, O);
      }
    }

    return A;
  };
}

// Polyfill for Array.prototype.filter
if (!Array.prototype.filter) {
  Array.prototype.filter = function(callback, thisArg) {
    if (this == null) {
      throw new TypeError('Array.prototype.filter called on null or undefined');
    }
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    const O = Object(this);
    const len = O.length >>> 0;
    const T = thisArg;
    const A = [];
    let k = 0;

    while (k < len) {
      if (k in O) {
        const element = O[k];
        if (callback.call(T, element, k, O)) {
          A.push(element);
        }
      }
      k++;
    }

    return A;
  };
}

// Polyfill for Array.prototype.reduce
if (!Array.prototype.reduce) {
  Array.prototype.reduce = function(callback, initialValue) {
    if (this == null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    const O = Object(this);
    const len = O.length >>> 0;
    let k = 0;
    let accumulator;

    if (arguments.length > 1) {
      accumulator = initialValue;
    } else {
      while (k < len && !(k in O)) {
        k++;
      }
      if (k >= len) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      accumulator = O[k++];
    }

    while (k < len) {
      if (k in O) {
        accumulator = callback.call(undefined, accumulator, O[k], k, O);
      }
      k++;
    }

    return accumulator;
  };
}

// Example Usage:
const numbers = [1, 2, 3, 4, 5];

// Using map polyfill
const doubled = numbers.map(function(number) {
  return number * 2;
});
console.log("Doubled:", doubled); // Output: Doubled: [ 2, 4, 6, 8, 10 ]

// Using filter polyfill
const evenNumbers = numbers.filter(function(number) {
  return number % 2 === 0;
});
console.log("Even Numbers:", evenNumbers); // Output: Even Numbers: [ 2, 4 ]

// Using reduce polyfill
const sum = numbers.reduce(function(accumulator, currentValue) {
  return accumulator + currentValue;
}, 0);
console.log("Sum:", sum); // Output: Sum: 15
```

**Explanation of each polyfill:**

**1. `Array.prototype.map` Polyfill:**

* **Checks for Existence:** It first checks if `Array.prototype.map` already exists. If it does, the polyfill does nothing.
* **Handles `null` or `undefined`:** It throws a `TypeError` if `this` (the array on which `map` is called) is `null` or `undefined`.
* **Checks for Function:** It ensures that the `callback` argument is a function.
* **Object Conversion:** It converts the `this` value to an object (`O`).
* **Gets Length:** It gets the length of the array using a bitwise right shift (`>>> 0`) to ensure it's a non-negative integer.
* **Handles `thisArg`:** It stores the optional `thisArg` which will be used as `this` inside the `callback`.
* **Creates New Array:** It creates a new array `A` with the same length as the original array.
* **Iterates and Applies Callback:** It iterates through the original array. For each element that exists (using `k in O`), it calls the `callback` function with the following arguments:
    * `O[k]` (the current element)
    * `k` (the current index)
    * `O` (the original array)
    * The result of the `callback` is assigned to the corresponding index in the new array `A`.
* **Returns New Array:** Finally, it returns the newly created array `A`.

**2. `Array.prototype.filter` Polyfill:**

* **Similar Initial Checks:** It performs similar checks for the existence of `filter`, `null`/`undefined` `this`, and the `callback` being a function.
* **Iterates and Applies Callback:** It iterates through the original array. For each element, it calls the `callback` function with the element, index, and the original array.
* **Conditional Push:** If the `callback` function returns a truthy value for an element, that element is pushed into the new array `A`.
* **Returns New Array:** It returns the new array `A` containing only the elements for which the `callback` returned a truthy value.

**3. `Array.prototype.reduce` Polyfill:**

* **Similar Initial Checks:** It performs similar checks for the existence of `reduce`, `null`/`undefined` `this`, and the `callback` being a function.
* **Handles Initial Value:**
    * If an `initialValue` is provided as the second argument, the `accumulator` is initialized with this value, and the iteration starts from the first element of the array.
    * If no `initialValue` is provided:
        * It finds the first element in the array that exists and uses it as the initial `accumulator`.
        * The iteration then starts from the next element.
        * If the array is empty and no `initialValue` is provided, it throws a `TypeError`.
* **Iterates and Applies Callback:** It iterates through the remaining elements of the array. For each element, it calls the `callback` function with the following arguments:
    * `accumulator` (the value returned from the previous callback invocation, or the initial value)
    * `O[k]` (the current element)
    * `k` (the current index)
    * `O` (the original array)
    * The return value of the `callback` becomes the new `accumulator` for the next iteration.
* **Returns Accumulator:** Finally, it returns the final `accumulator` value.

**Why are Polyfills Necessary?**

Polyfills are essential for ensuring that your JavaScript code works correctly in older browsers or JavaScript environments that don't natively support newer ECMAScript features like `map`, `filter`, and `reduce`. By including these polyfills, you provide the missing functionality, allowing you to use these powerful array methods consistently across different environments.

**How to Use:**

You can include these polyfill code snippets directly in your JavaScript file, preferably at the beginning, before any code that uses these array methods. The polyfills will only be applied if the native implementations are not found.
